import pandas as pd
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C, WhiteKernel
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import joblib

# Load and parse data
df = pd.read_excel("TSA 실험데이터_250923.xlsx", sheet_name="Sheet2", header=None)

rows = []
block_starts = [(3, 15), (22, 20), (41, 25)]
diameters = [1, 1.5, 2]
n_wire_labels = [2, 3, 4, 5, 6, 7]

for block_start, weight in block_starts:
    for d_idx, diameter in enumerate(diameters):
        col_block = 2 + d_idx * 8
        area_row = block_start + 1
        for ci in range(len(n_wire_labels)):
            if area_row < df.shape[0] and (col_block + ci) < df.shape[1]:
                val = df.iloc[area_row, col_block + ci]
                try:
                    area = float(val)
                except Exception:
                    area = np.nan
                for rep in range(1, 9):
                    data_row = area_row + rep
                    if data_row < df.shape[0] and (col_block + ci) < df.shape[1]:
                        try:
                            executions = float(df.iloc[data_row, col_block + ci])
                            rows.append({
                                "Weight": weight,
                                "Diameter": diameter,
                                "NumWires": n_wire_labels[ci],
                                "Area": area,
                                "Executions": executions
                            })
                        except Exception:
                            continue

data = pd.DataFrame(rows).dropna()

print(f"✅ Parsed {len(data)} valid experiment rows")
print(data.head())

X = data[["Weight", "Diameter", "NumWires", "Area"]]
y = np.log1p(data["Executions"])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define kernel (RBF + White noise + Constant)
kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=1.0) + WhiteKernel(noise_level=1)

gpr = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, random_state=42)
gpr.fit(X_train, y_train)

y_pred, y_std = gpr.predict(X_test, return_std=True)

r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mae = mean_absolute_error(y_test, y_pred)

print("\n===== Gaussian Process Regression =====")
print(f"R² (log scale): {r2:.4f}")
print(f"RMSE (log scale): {rmse:.4f}")
print(f"MAE (log scale): {mae:.4f}")
print(f"RMSE (real scale): {np.expm1(rmse):.2f} cycles")

print("\nKernel used:", gpr.kernel_)

joblib.dump(gpr, "tsa_cycle_predictor_GPR.pkl")
print("✅ Model saved as tsa_cycle_predictor_GPR.pkl")

# Predictions with uncertainty
sample_inputs = np.array([
    [15, 1.0, 3, 2.35],
    [20, 1.5, 4, 5.3],
    [25, 2.0, 6, 12.56]
])
preds, stds = gpr.predict(sample_inputs, return_std=True)

print("\nPredictions with Uncertainty (Real Scale):")
for x, p, s in zip(sample_inputs, np.expm1(preds), stds):
    print(f"{x} → {p:.0f} ± {np.expm1(s):.0f} cycles (1σ)")
